{% load static %}
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>To-Do ‚Äî Dashboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{% static 'css/style.css' %}">
</head>
<body>
  <div class="app-shell">

    <!-- SIDEBAR -->
    <aside class="sidebar">
      <div class="brand">
        <h2>To-Do</h2>
        <p class="muted">Smart ‚Ä¢ Minimal</p>
      </div>

      <nav class="sidebar-nav" role="navigation" aria-label="Main">
        <button class="sb-btn active" data-filter="all">All Tasks</button>
        <button class="sb-btn" data-filter="pending">To-Do</button>
        <button class="sb-btn" data-filter="completed">Completed</button>
        <button class="sb-btn" data-filter="archived">Archived</button>
      </nav>

      <div class="sidebar-footer">
        {% if request.session.user_email %}
          <div class="user">
            <div class="avatar">{{ request.session.user_email|slice:":1"|upper }}</div>
            <div class="user-info">
              <div class="user-email">{{ request.session.user_email }}</div>
              <a href="/auth/logout/" class="logout-link">Logout</a>
            </div>
          </div>
        {% else %}
          <div class="auth-links">
            <a href="/auth/login/" class="link">Sign in</a>
            <a href="/auth/signup/" class="link">Sign up</a>
          </div>
        {% endif %}
      </div>
    </aside>

    <!-- MAIN -->
    <main class="main">

      <!-- HEADER / STATS ROW -->
      <header class="main-header">
        <div>
          <h1 class="title">Task Manager</h1>
          <p class="subtle">A focused, minimal workspace for your tasks</p>
        </div>

        <div class="header-widgets">
          <div class="stats-row" aria-hidden="true">
            <div class="stat">
              <div class="stat-value" id="stat-total">0</div>
              <div class="stat-title">Total</div>
            </div>
            <div class="stat">
              <div class="stat-value" id="stat-completed">0</div>
              <div class="stat-title">Completed</div>
            </div>
            <div class="stat">
              <div class="stat-value" id="stat-pending">0</div>
              <div class="stat-title">Pending</div>
            </div>
            <div class="stat">
              <div class="stat-value" id="stat-archived">0</div>
              <div class="stat-title">Archived</div>
            </div>
          </div>

          <!-- small circular overall (optional) -->
          <div class="donut-wrap">
            <canvas id="donut" width="92" height="92"></canvas>
            <div class="donut-center"><span id="donut-total">0</span><small>Total</small></div>
          </div>
        </div>
      </header>

      <!-- Controls -->
      <section class="controls">
        <input id="search-bar" placeholder="Search tasks..." />
        <select id="sort-order">
          <option value="newest">Newest</option>
          <option value="oldest">Oldest</option>
          <option value="upcoming">Upcoming</option>
        </select>
      </section>

      <!-- Add Task form -->
      <section class="add-task">
        <form id="todo-form" class="glass-form">
          <input id="title" type="text" placeholder="Task title..." required>
          <textarea id="description" placeholder="Describe (optional)"></textarea>

          <div class="row">
            <input id="due-date" type="date" />
            <select id="priority">
              <option value="Low">Low Priority</option>
              <option value="Medium">Medium Priority</option>
              <option value="High">High Priority</option>
            </select>
            <button type="submit" class="primary-btn">+ Add Task</button>
          </div>
        </form>
      </section>

      <!-- Overall progress (linear) -->
      <section class="progress-section">
        <div class="progress-header">
          <h3>Overall Progress</h3>
          <p id="progress-text">0% completed</p>
        </div>
        <div class="progress-bar"><div id="progress-fill"></div></div>
      </section>

      <!-- Task list -->
      <section id="task-list" class="task-list">
        <!-- tasks injected here -->
      </section>

    </main>
  </div>

  <!-- Confirmation modal -->
  <div id="confirm-modal" class="modal hidden" aria-hidden="true">
    <div class="modal-card">
      <h3>Confirm Permanent Delete</h3>
      <p>Are you sure you want to permanently delete this task? This cannot be undone.</p>
      <div class="modal-actions">
        <button id="confirm-cancel" class="btn-muted">Cancel</button>
        <button id="confirm-ok" class="btn-danger">Delete Permanently</button>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
  Config & state
---------------------------- */
const API_URL = "/api/todos/";
let allTasks = [];
let currentFilter = "all";
let searchQuery = "";
let sortOrder = "newest";

/* helpers */
const qs = sel => document.querySelector(sel);
const qsa = sel => Array.from(document.querySelectorAll(sel));
function formatDate(dstr){
  if(!dstr) return "No due date";
  const d = new Date(dstr);
  return isNaN(d) ? dstr : d.toLocaleDateString();
}
function escapeHtml(s){
  return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]));
}

/* ---------------------------
  Fetch & render
---------------------------- */
async function loadTodos(){
  try{
    const res = await fetch(API_URL);
    allTasks = await res.json();
  }catch(e){
    console.error("loadTodos failed:", e);
    allTasks = [];
  }
  renderTasks();
  drawDonutAnimated();
}

function renderTasks(){
  const container = qs("#task-list");
  // filter
  let items = allTasks.filter(t => {
    if(currentFilter === "all") return !t.deleted;
    if(currentFilter === "pending") return !t.completed && !t.archived && !t.deleted;
    if(currentFilter === "completed") return t.completed && !t.deleted;
    if(currentFilter === "archived") return t.archived && !t.deleted;
    return true;
  });

  // search
  if(searchQuery){
    const q = searchQuery.toLowerCase();
    items = items.filter(t => (t.title||'').toLowerCase().includes(q) || (t.description||'').toLowerCase().includes(q));
  }

  // sort
  if(sortOrder === "newest") items.sort((a,b) => (b._id || b.id || 0) > (a._id || a.id || 0) ? 1 : -1);
  if(sortOrder === "oldest") items.reverse();

  container.innerHTML = "";
  if(!items.length){
    container.innerHTML = `<div class="empty">No tasks to show here.</div>`;
    updateDashboard();
    return;
  }

  items.forEach(todo => {
    const id = todo.id || todo._id || (todo._id && todo._id.$oid) || "";
    const card = document.createElement("article");
    card.className = `task-card ${todo.archived?'archived':''} ${todo.completed?'completed':''} ${todo.deleted?'deleted':''}`;

    card.innerHTML = `
      <div class="task-head">
        <canvas class="mini-can" width="48" height="48" data-id="${id}"></canvas>
        <div class="task-title-wrap">
          <h4 class="task-title">${escapeHtml(todo.title || 'Untitled')}</h4>
          <div class="task-meta">
            <span class="small muted">${escapeHtml(todo.description || '')}</span>
            <div class="meta-row">
              <small>üìÖ ${formatDate(todo.due_date)}</small>
              <small> ‚Ä¢ üî• ${escapeHtml(todo.priority || 'Low')}</small>
            </div>
          </div>
        </div>
        <div class="task-pct">${todo.progress || 0}%</div>
      </div>

      <div class="task-progress">
        <div class="progress-inner" style="width:${(todo.progress||0)}%"></div>
      </div>

      <div class="task-controls">
        ${!todo.deleted ? `
          <input type="range" min="0" max="100" value="${todo.progress||0}" class="progress-slider" data-id="${id}">
          <div class="task-actions">
            <button class="btn" data-act="toggle" data-id="${id}" data-val="${!!todo.completed}">${todo.completed? '‚Ü∫ Undo':'‚úî Complete'}</button>
            <button class="btn" data-act="archive" data-id="${id}" data-val="${!!todo.archived}">${todo.archived? 'Unarchive':'Archive'}</button>
            <button class="btn danger" data-act="bin" data-id="${id}">üóë Move to Bin</button>
          </div>
        ` : `
          <div class="task-actions">
            <button class="btn" data-act="restore" data-id="${id}">‚ôª Restore</button>
            <button class="btn danger" data-act="delete" data-id="${id}">‚ùå Delete Permanently</button>
          </div>
        `}
      </div>
    `;

    container.appendChild(card);

    // draw mini donut
    const mini = card.querySelector(".mini-can");
    drawMiniDonut(mini, todo.progress || 0);

    // attach slider listener (interactive)
    const slider = card.querySelector(".progress-slider");
    if(slider){
      // pointer interactions: update bars live, but debounce network PATCH
      let patchTimeout = null;
      slider.addEventListener("input", (ev) => {
        const val = Number(ev.target.value);
        // update card progress bar & percent text live
        const pctEl = card.querySelector(".task-pct");
        const innerBar = card.querySelector(".progress-inner");
        pctEl.textContent = `${val}%`;
        if(innerBar) innerBar.style.width = val + "%";
        drawMiniDonut(mini, val);

        // update overall progress visually immediately
        // compute new overall average as if this change applied
        const id = ev.target.dataset.id;
        const visible = allTasks.filter(t => !t.deleted);
        const replaced = visible.map(t => t.id == id || t._id == id ? {...t, progress: val} : t);
        const avg = replaced.length ? Math.round(replaced.reduce((s,t)=> s + (t.progress||0),0) / replaced.length) : 0;
        qs("#progress-fill").style.width = avg + "%";
        qs("#progress-text").textContent = `${avg}% completed`;
      });

      // on change (release) -> send to server (debounced small delay to avoid spamming)
      slider.addEventListener("change", (ev) => {
        const val = Number(ev.target.value);
        const tid = ev.target.dataset.id;
        // patch server
        apiPatch(tid, {progress: val}).then(() => loadTodos()).catch(e => console.error(e));
      });
    }
  });

  updateDashboard();
}

/* ---------------------------
  Dashboard update & donut
---------------------------- */
function updateDashboard(){
  const total = allTasks.filter(t => !t.deleted).length;
  const completed = allTasks.filter(t => t.completed && !t.deleted).length;
  const pending = allTasks.filter(t => !t.completed && !t.archived && !t.deleted).length;
  const archived = allTasks.filter(t => t.archived && !t.deleted).length;

  qs("#stat-total").textContent = total;
  qs("#stat-completed").textContent = completed;
  qs("#stat-pending").textContent = pending;
  qs("#stat-archived").textContent = archived;

  const visible = allTasks.filter(t => !t.deleted);
  const avg = visible.length ? Math.round(visible.reduce((s,t)=> s + (t.progress || 0),0) / visible.length) : 0;
  qs("#progress-fill").style.width = avg + "%";
  qs("#progress-text").textContent = `${avg}% completed`;
  qs("#donut-total").textContent = total;
}

/* animated donut (small) that shows distribution Completed / Pending / Archived */
function drawDonutAnimated(){
  const canvas = qs("#donut");
  if(!canvas) return;
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 8;
  const completed = allTasks.filter(t=>t.completed && !t.deleted).length;
  const archived = allTasks.filter(t=>t.archived && !t.deleted).length;
  const pending = allTasks.filter(t=>!t.completed && !t.archived && !t.deleted).length;
  const total = completed + pending + archived || 1;

  const segments = [
    {value: completed, color: '#16a34a'},
    {value: pending, color: '#2563eb'},
    {value: archived, color: '#7c3aed'}
  ];

  const duration = 600;
  const start = performance.now();
  function frame(now){
    const t = Math.min(1, (now-start)/duration);
    const ease = 1 - Math.pow(1 - t, 3);

    ctx.clearRect(0,0,w,h);

    // background ring
    ctx.beginPath();
    ctx.arc(cx,cy,r+6,0,Math.PI*2);
    ctx.lineWidth = 12;
    ctx.strokeStyle = '#eef2f7';
    ctx.stroke();

    // segments
    let angleStart = -Math.PI/2;
    for(const seg of segments){
      const segAngle = (seg.value/total) * Math.PI * 2 * ease;
      if(seg.value > 0){
        ctx.beginPath();
        ctx.arc(cx,cy,r, angleStart, angleStart + segAngle);
        ctx.lineWidth = 12;
        ctx.lineCap = 'round';
        ctx.strokeStyle = seg.color;
        ctx.stroke();
      }
      angleStart += (seg.value/total) * Math.PI * 2;
    }

    // donut hole
    ctx.beginPath();
    ctx.arc(cx,cy, r-14,0,Math.PI*2);
    ctx.fillStyle = '#fff';
    ctx.fill();

    if(t < 1) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

/* mini donut for each task */
function drawMiniDonut(canvas, pct){
  if(!canvas) return;
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 6;
  ctx.clearRect(0,0,w,h);

  // base ring
  ctx.beginPath();
  ctx.arc(cx,cy,r,0,Math.PI*2);
  ctx.lineWidth = 6;
  ctx.strokeStyle = '#eef2f7';
  ctx.stroke();

  // progress
  const ang = (pct/100) * Math.PI*2;
  ctx.beginPath();
  ctx.arc(cx,cy,r,-Math.PI/2, -Math.PI/2 + ang);
  ctx.lineWidth = 6;
  ctx.lineCap = 'round';
  ctx.strokeStyle = pct >= 80 ? '#16a34a' : (pct >= 40 ? '#2563eb' : '#f59e0b');
  ctx.stroke();

  // center number
  ctx.font = "10px Inter, sans-serif";
  ctx.fillStyle = '#374151';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(pct) + '%', cx, cy);
}

/* ---------------------------
  API helpers & interactions
---------------------------- */
async function apiPost(data){
  await fetch(API_URL, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(data)
  });
}
async function apiPatch(id, data){
  await fetch(`${API_URL}${id}/`, {
    method: 'PATCH',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(data)
  });
}
async function apiDelete(id){
  await fetch(`${API_URL}${id}/`, { method: 'DELETE' });
}

/* add task */
qs("#todo-form").addEventListener("submit", async e => {
  e.preventDefault();
  const data = {
    title: qs("#title").value.trim(),
    description: qs("#description").value.trim(),
    due_date: qs("#due-date").value || null,
    priority: qs("#priority").value,
    progress: 0,
    deleted: false,
    archived: false,
    completed: false
  };
  await apiPost(data);
  e.target.reset();
  await loadTodos();
});

/* delegated task action clicks */
qs("#task-list").addEventListener("click", async ev => {
  const btn = ev.target.closest("button");
  if(!btn) return;
  const act = btn.dataset.act;
  const id = btn.dataset.id;
  if(!act || !id) return;

  if(act === "toggle"){
    const cur = btn.dataset.val === 'true';
    await apiPatch(id, { completed: !cur });
    await loadTodos();
  } else if(act === "archive"){
    const cur = btn.dataset.val === 'true';
    await apiPatch(id, { archived: !cur });
    await loadTodos();
  } else if(act === "bin"){
    await apiPatch(id, { deleted: true });
    await loadTodos();
  } else if(act === "restore"){
    await apiPatch(id, { deleted: false });
    await loadTodos();
  } else if(act === "delete"){
    showConfirm(id);
  }
});

/* confirm modal */
let _confirmTarget = null;
function showConfirm(id){
  _confirmTarget = id;
  qs("#confirm-modal").classList.remove("hidden");
  qs("#confirm-modal").setAttribute("aria-hidden", "false");
}
qs("#confirm-cancel").addEventListener("click", () => {
  _confirmTarget = null;
  qs("#confirm-modal").classList.add("hidden");
  qs("#confirm-modal").setAttribute("aria-hidden", "true");
});
qs("#confirm-ok").addEventListener("click", async () => {
  if(!_confirmTarget) return;
  await apiDelete(_confirmTarget);
  _confirmTarget = null;
  qs("#confirm-modal").classList.add("hidden");
  qs("#confirm-modal").setAttribute("aria-hidden", "true");
  await loadTodos();
});

/* sidebar filter */
qsa(".sb-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    qsa(".sb-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    currentFilter = btn.dataset.filter;
    renderTasks();
  });
});

/* search & sort */
qs("#search-bar").addEventListener("input", e => {
  searchQuery = e.target.value;
  renderTasks();
});
qs("#sort-order").addEventListener("change", e => {
  sortOrder = e.target.value;
  renderTasks();
});

/* init */
loadTodos();

/* on resize redraw mini canvases for crispness */
window.addEventListener("resize", () => {
  qsa(".mini-can").forEach(c => {
    const id = c.dataset.id;
    const todo = allTasks.find(t => (t.id == id) || (t._id == id));
    if(todo) drawMiniDonut(c, todo.progress || 0);
  });
});
</script>
</body>
</html>
